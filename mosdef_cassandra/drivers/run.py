

def run(system, moves, temperature, sim_type, length, **kwargs):

    # Sanity checks
    # E.g., system has multiple boxes for GEMC

    ensemble = moves.ensemble
    if ensemble == 'gemc' or ensemble == 'gemc_npt':
        if len(system.boxes) != 2:
            raise ValueError('{} requested but {} simulation'
                    'boxes provided as part of system. {} requires'
                    '2 simulation boxes'.format(ensemble,
                        len(system.boxes), ensemble))

    # Write MCF files
    write_mcfs(system)

    # Write starting configs (if needed)
    write_configs(system)

    # Write input file

    # Run fragment generation

    # Run simulation

def generate_inp(system, moves, temperature, run_type, length, **kwargs):

    # Sanity check on kwargs
    valid_args = ['']

    for arg in kwargs:
        if arg not in valid_args:
            raise ValueError('Invaild probability info section {}. '
                    'Allowable options include {}'.format(
                     arg,valid_args))


    # Construct an input file section by section

    inp_data = """
! Generated by on {}""".format(datetime.datetime.now())

    # Extract some basic info
    nbr_species = len(system.species_topologies)
    nbr_boxes = len(system.boxes)

    # Name and ensemble
    if 'run_name' in kwargs:
        run_name = kwargs['run_name']
    else:
        run_name = 'nvt'
    inp_data += write_inp.run_name(run_name)
    inp_data += write_inp.sim_type(moves.ensemble)

    # Number of species
    inp_data += write_inp.nbr_species(nbr_species)

    # VDW Style
    # NOTE: Once more than LJ is supported (topology object)
    # this can be inferred from system.species
    if 'vdw_style' in kwargs:
        vdw_style = kwargs['vdw_style']
    else:
        vdw_style = 'lj'

    if 'cutoff_style' in kwargs:
        cutoff_style = kwargs['cutoff_style']
    else:
        cutoff_style = 'cut_tail'

    if 'vdw_cutoff' in kwargs:
        vdw_cutoff = kwargs['vdw_cutoff']
    else:
        vdw_cutoff = 12.0

    vdw_styles = [vdw_style] * nbr_boxes
    cutoff_styles = [cutoff_style] * nbr_boxes
    vdw_cutoffs = [vdw_cutoff] * nbr_boxes
    # Support for per-box cutoffs
    if 'vdw_cutoff_box1' in kwargs:
        vdw_cutoffs[0] = kwargs['vdw_cutoff_box1']
    if 'vdw_cutoff_box2' in kwargs:
        vdw_cutoffs[1] = kwargs['vdw_cutoff_box2']

    inp_data += write_inp.vdw_style(vdw_styles,cutoff_styles,vdw_cutoffs)

    # Charge Style
    if 'charge_style' in kwargs:
        charge_style = kwargs['charge_style']
    else:
        charge_style = 'ewald'

    if 'charge_cutoff' in kwargs:
        charge_cutoff = kwargs['charge_cutoff']
    else:
        charge_cutoff = 12.0

    if 'ewald_accuracy' in kwargs:
        ewald_accuracy = kwargs['ewald_accuracy']
    else:
        ewald_accuracy = 1.0e-5

    if 'dsf_damping' in kwargs:
        dsf_damping = kwargs['dsf_damping']
    else:
        dsf_damping = None

    charge_styles = [charge_style]*nbr_boxes
    charge_cutoffs = [charge_cutoff]*nbr_boxes

    # Support for per-box cutoffs
    if 'charge_cutoff_box1' in kwargs:
        charge_cutoffs[0] = kwargs['charge_cutoff_box1']
    if 'charge_cutoff_box2' in kwargs:
        charge_cutoffs[1] = kwargs['charge_cutoff_box2']

    inp_data += write_inp.charge_style(charge_styles,charge_cutoffs,
            ewald_accuracy=ewald_accuracy,dsf_damping=dsf_damping)

    # NOTE: In future get mixing rule from Topology
    if 'mixing_rule' in kwargs:
        mixing_rule = kwargs['mixing_rule']
    else:
        mixing_rule = 'lb'

    inp_data += write_inp.mixing_rule(mixing_rule)

    # Seeds
    if 'seeds' in kwargs:
        # TODO: Check format of seeds
        seed1 = kwargs['seeds'][0]
        seed2 = kwargs['seeds'][1]
    else:
        seed1 = None
        seed2 = None
    inp_data += write_inp.seed_info(seed1,seed2)

    # Minimum cutoff
    if 'rcut_min' in kwargs:
        rcut_min = kwargs['rcut_min']
    else:
        rcut_min = 1.0
    inp_data += write_inp.minimum_cutoff(rcut_min)

    # Pair Energy
    if 'pair_energy' not kwargs:
        pair_energy = kwargs['pair_energy']
    else:
        pair_energy=True
    inp_data += write_inp.pair_energy(pair_energy)

    # Molecule Files
    max_molecules_dict = {'species%d.mcf' % i+1 : 0
                          for i in range(nbr_species) }
    if 'max_molecules' in kwargs:
        if len(kwargs['max_molecules']) != nbr_species:
            raise ValueError('Length of list specified with '
                    '"max_molecules" ({})must be equal to the number '
                    'of species in the system ({})'.format(
                        len(kwargs['max_molecules']),nbr_species))
        for i,max_mols in enumerate(max_molecules):
            max_molecules_dict['species%d.mcf' % i+1] = max_mols
    else:
        sp_idx = 0
        for n_in_box, n_to_add in zip(system.species_in_boxes,
                                      system.species_to_add):
            sp_idx += 1
            n_total = n_in_box + n_to_add
            if moves.ensemble == 'gemc' or moves.ensemble == 'gemc_npt':
                n_total = n_total + 500
            max_molecule_dict['species%d.mcf' % sp_idx] = n_total

    inp_data += write_inp.molecule_files(max_molecule_dict)

    # Box Info
    boxes = []
    for box in system.boxes:
        box_dims = np.hstack((box.boundingbox.lengths,
                              box.boundingbox.angles))
        box_matrix = convert_box.triclinic_vectors(box_dims)
        boxes.append(box_matrix)
    inp_data += box_info(boxes)

    temperatures = [temperature] * nbr_boxes
    inp_data += write_inp.temperature_info(temperatures)

    if moves.ensemble == 'npt' or moves.ensemble == 'gemc_npt':
        if 'pressure' in kwargs:
            pressure = kwargs['pressure']
        else:
            raise ValueError('Pressure must be specified for ensemble '
                    '"npt" or "gemc_npt"')
        pressures = [pressure] * nbr_boxes
        if 'pressure_box1' in kwargs:
            pressures[0] = kwargs['pressure_box1']
        if 'pressure_box2' in kwargs:
            pressures[1] = kwargs['pressure_box2']

        inp_data += write_inp.pressure_info(pressures)

    if moves.ensemble == 'gcmc':
        if 'chemical_potentials' in kwargs:
            chemical_potentials = kwargs['chemical_potential']
        else:
            raise ValueError('Chemical potential information must be '
                'specified for each species if the ensemble is '
                '"gcmc". The chemical potential of non-insertable '
                'species should be "none"')
        if len(chemical_potentials) != nbr_species:
            raise ValueError('Chemical potential information must be '
                'specified for each species if the ensemble is '
                '"gcmc". The chemical potential of non-insertable '
                'species should be "none"')

        inp_data += write_inp.chemical_potential_info(chemical_potentials)

    # Move probability info
    move_prob_dict = {}
    if moves.prob_translate > 0.0:
        move_prob_dict['trans'] = [moves.prob_translate,
                                  *moves.max_translate]
    if moves.prob_rotate > 0.0:
        move_prob_dict['rot'] = [moves.prob_rotate,
                                *moves.max_rotate]
    if moves.prob_angle > 0.0:
        move_prob_dict['angle'] = moves.prob_angle

    if moves.prob_dihedral > 0.0
        move_prob_dict['dihedral'] = [moves.prob_dihedral,
                                      moves.max_dihedrals]
    if moves.prob_regrow > 0.0:
        move_prob_dict['regrow'] = [moves.prob_regrow,
                                    moves.sp_prob_regrow]
    if moves.prob_vol > 0.0:
        move_prob_dict['vol'] = [moves.prob_vol,
                                 moves.max_volume]
    if moves.prob_insert > 0.0:
        move_prob_dict['insert'] = [moves.prob_insert,
                                    moves.sp_insertable]
    if moves.prob_swap > 0.0:
        move_prob_dict['swap'] = [ moves.prob_swap,
                                   moves.sp_insertable,
                                   moves.sp_swap_prob,
                                   moves.prob_swap_from_box ]

    inp_data += write_inp.move_probability_info(move_prob_dict)

    for ibox,box in enumerate(system.boxes):
        if box.n_particles > 0:
            if sum(system.species_to_add[ibox]) > 0:
                existing_mols = ' '.join(
                        [str(x) for x in system.species_in_boxes])
                xyz_name = 'box{}.in.xyz'.format(ibox+1)
                new_mols = ' '.join([str(x)
                                 for x in system.species_to_add[ibox]])
                start_type = 'add_to_config '
                start_type += existing_mols + ' '
                start_type += xyz_name + ' '
                start_type += new_mols
                start_types.append(start_type)
            else:
                existing_mols = ' '.join(
                        [str(x) for x in system.species_in_boxes])
                xyz_name = 'box{}.in.xyz'.format(ibox+1)
                start_type = 'read_config '
                start_type += existing_mols + ' '
                start_type += xyz_name
                start_types.append(start_type)
        else:
            new_mols = ' '.join([str(x) for x in system.species_to_add[ibox]])
            start_type = 'make_config ' + new_mols
            start_types.append(start_type)

    inp_data += write_inp.start_type(start_types)

    # Move statistics/updating
    if 'thermal_stat_freq' in kwargs:
        thermal_stat_freq = kwargs['thermal_stat_freq']
    else:
        thermal_stat_freq = 1000

    if moves.ensemble == 'npt' or moves.ensemble == 'gemc_npt':
        if 'vol_stat_freq' in kwargs:
            vol_stat_freq = kwargs['vol_stat_freq']
        else:
            vol_stat_freq = 100
    else:
        vol_stat_freq = None

    inp_data += write_inp.run_type(run_type,thermal_stat_freq,vol_stat_freq)

    if 'units' in kwargs:
        units = kwargs['units']
    else:
        units = 'steps'

    if 'prop_freq' in kwargs:
        prop_freq = kwargs['prop_freq']
    else:
        prop_freq = 1000

    if 'coord_freq' in kwargs:
        coord_freq = kwargs['coord_freq']
    else:
        coord_freq = 10000

    # TODO: Change units to sweeps and come up with
    # a smart way of calculating the number of sweeps
    if 'steps_per_sweep' in kwargs:
        steps_per_sweep = kwargs['steps_per_sweep']
    else:
        steps_per_sweep = None

    if 'block_avg_freq' in kwargs:
        block_avg_freq = kwargs['block_avg_freq']
    else:
        block_avg_freq = None

    inp_data += write_inp.simulation_length_info(units,prop_freq,
                coord_freq,length,steps_per_sweep,block_avg_freq)

    inp_data += write_inp.get_fragment_files()

    if 'verbose_log' in kwargs:
        verbose_log = kwargs['verbose_log']
    else:
        verbose_log = False

    if verbose_log:
        inp_data += write_inp.get_verbose_log(verbose_log)

    # TODO: RSD YOU ARE HERE

    if 'run_type' not in kwargs:
        run_type = 'equilibration'
    if 'properties' not in kwargs:
        properties = 'all'


    inp_data += write_inp.properties(properties)

def generate_inp_nvt(system, moves, temperature, length):

    inp_data = """
! Generated by on {}"""

    # Extract information and add defaults
    if 'run_name' not in kwargs:
        run_name = 'nvt'
    inp_data += write_inp.run_name(run_name)
    inp_data += write_inp.sim_type('nvt_mc')

    nbr_species = len(species)
    inp_data += write_inp.nbr_species(nbr_species)

    # VDW Style
    if 'vdw_style' not in kwargs:
        vdw_style = 'lj'
    if 'cutoff_style' not in kwargs:
        cutoff_style = 'cut_tail'
    if 'cutoff' not in kwargs:
        cutoff = 12.0
    inp_data += write_inp.vdw_style([vdw_style],[cutoff_style],[cutoff])

    # Charge Style
    if 'charge_style' not in kwargs:
        charge_style = 'ewald'
    if 'ewald_accuracy' not in kwargs:
        ewald_accuracy = 1.0e-5

    inp_data += write_inp.charge_style([charge_style],[cutoff],
            ewald_accuracy=ewald_accuracy)

    if 'mixing_rule' not in kwargs:
        mixing_rule = 'lb'
    inp_data += write_inp.mixing_rule(mixing_rule)

    if 'seeds' not in kwargs:
        seed1 = None
        seed2 = None
    inp_data += write_inp.seed_info(seed1,seed2)

    if 'rcut_min' not in kwargs:
        rcut_min = 1.0
    inp_data += write_inp.minimum_cutoff(rcut_min)

    if 'pair_energy' not in kwargs:
        pair_energy=True
    inp_data += write_inp.pair_energy(pair_energy)

    # TODO: think harder about this section
    #if 'molecule_files' not in kwargs:

    inp_data += box_info([box])
    inp_data += temperature_info([temperature])


    if 'start_type' not in kwargs:
        start_type = 'make_config'

    inp_data += write_inp.start_type([start_type])

    if 'run_type' not in kwargs:
        run_type = 'equilibration'
    if 'properties' not in kwargs:
        properties = 'all'

    inp_data += write_inp.run_type(run_type,100)

    inp_data += write_inp.properties(properties)
